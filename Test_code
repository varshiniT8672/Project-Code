"""Financial Data Bot using Alternative APIs.

This bot provides real-time stock and Bitcoin price information.
Uses Finnhub API for stocks and CoinGecko for Bitcoin.
"""

import logging
import re
from typing import Any, Dict, List, Optional, TypedDict
from datetime import datetime
import requests
import urllib3
import ssl
import os
from langgraph.graph import END, START, StateGraph
from langgraph.graph.state import CompiledStateGraph
from pydantic_settings import BaseSettings

# Aggressive SSL bypass for corporate firewalls
ssl._create_default_https_context = ssl._create_unverified_context
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
os.environ['CURL_CA_BUNDLE'] = ''
os.environ['REQUESTS_CA_BUNDLE'] = ''

class Settings(BaseSettings):
    """Configuration settings for the financial bot."""

    class Config:
        env_file = '.env'
        env_file_encoding = 'utf-8'
        extra = 'ignore'

settings = Settings()

def setup_logging(level: int = logging.INFO) -> None:
    """Configure the root logger with consistent formatting."""
    logger = logging.getLogger()
    logger.setLevel(level)

    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    handler = logging.StreamHandler()
    handler.setLevel(level)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

class BotState(TypedDict):
    """State schema for the financial bot."""
    user_query: str
    query_type: Optional[str]
    ticker_symbol: Optional[str]
    stock_data: Optional[Dict[str, Any]]
    bitcoin_data: Optional[Dict[str, Any]]
    response: Optional[str]
    error_message: Optional[str]

def initialize_state(state: Dict[str, Any]) -> BotState:
    """Initialize the bot's state from user input."""
    logging.info("Initializing bot state")

    user_query = state.get("user_query", "")
    logging.info(f"Processing query: '{user_query}'")

    return {
        "user_query": user_query,
        "query_type": None,
        "ticker_symbol": None,
        "stock_data": None,
        "bitcoin_data": None,
        "response": None,
        "error_message": None
    }

# Company name to ticker lookup dictionary
COMPANY_LOOKUP = {
    'apple': 'AAPL',
    'microsoft': 'MSFT',
    'google': 'GOOGL',
    'alphabet': 'GOOGL',
    'amazon': 'AMZN',
    'tesla': 'TSLA',
    'meta': 'META',
    'facebook': 'META',
    'netflix': 'NFLX',
    'nvidia': 'NVDA',
    'amd': 'AMD',
    'intel': 'INTC',
    'jpmorgan': 'JPM',
    'bank of america': 'BAC',
    'wells fargo': 'WFC',
    'goldman sachs': 'GS',
    'morgan stanley': 'MS',
    'berkshire hathaway': 'BRK.B',
    'johnson & johnson': 'JNJ',
    'procter & gamble': 'PG',
    'coca cola': 'KO',
    'pepsi': 'PEP',
    'walmart': 'WMT',
    'disney': 'DIS',
    'nike': 'NKE',
    'mcdonald': 'MCD',
    'mcdonalds': 'MCD',
    'visa': 'V',
    'mastercard': 'MA',
    'salesforce': 'CRM',
    'oracle': 'ORCL',
    'cisco': 'CSCO',
    'ibm': 'IBM',
    'ge': 'GE',
    'general electric': 'GE',
    'ford': 'F',
    'general motors': 'GM',
    'gm': 'GM',
    'boeing': 'BA',
    'caterpillar': 'CAT',
    'home depot': 'HD',
    'lowes': 'LOW',
    'target': 'TGT',
    'costco': 'COST',
    'starbucks': 'SBUX',
    'ups': 'UPS',
    'fedex': 'FDX',
    'exxon': 'XOM',
    'chevron': 'CVX',
    'pfizer': 'PFE',
    'moderna': 'MRNA',
    'abbvie': 'ABBV',
    'zoom': 'ZM',
    'spotify': 'SPOT',
    'uber': 'UBER',
    'lyft': 'LYFT',
    'airbnb': 'ABNB',
    'snapchat': 'SNAP',
    'paypal': 'PYPL',
    'square': 'SQ',
    'robinhood': 'HOOD'
}

def find_ticker_from_company_name(query: str) -> str:
    """Find ticker symbol from company name in the query."""
    query_lower = query.lower()

    for company_name in sorted(COMPANY_LOOKUP.keys(), key=len, reverse=True):
        if company_name in query_lower:
            ticker = COMPANY_LOOKUP[company_name]
            logging.info(f"Found company '{company_name}' -> ticker: {ticker}")
            return ticker

    return None

def analyze_query(state: BotState) -> BotState:
    """Analyze user query to determine intent and extract relevant information."""
    logging.info("Analyzing user query")

    query = state["user_query"].lower().strip()

    # Check for Bitcoin/crypto keywords
    bitcoin_keywords = ['bitcoin', 'btc', 'crypto', 'cryptocurrency']
    if any(keyword in query for keyword in bitcoin_keywords):
        logging.info("Detected Bitcoin query")
        return {**state, "query_type": "bitcoin"}

    # Try to find company names
    company_ticker = find_ticker_from_company_name(state["user_query"])
    if company_ticker:
        logging.info(f"Detected stock query for company name -> ticker: {company_ticker}")
        return {**state, "query_type": "stock", "ticker_symbol": company_ticker}

    # Check for stock tickers
    stock_pattern = r'\b[A-Z]{2,5}\b'
    matches = re.findall(stock_pattern, state["user_query"])

    common_words = {'I', 'IS', 'IT', 'IN', 'ON', 'TO', 'OF', 'THE', 'AND', 'OR', 'BUT', 'GET', 'CAN', 'HOW', 'YOU', 'YOUR'}
    valid_tickers = [match for match in matches if match not in common_words]

    if valid_tickers:
        ticker = valid_tickers[0]
        logging.info(f"Detected stock query for ticker: {ticker}")
        return {**state, "query_type": "stock", "ticker_symbol": ticker}

    # Check for stock-related words
    stock_keywords = ['stock', 'share', 'price', 'ticker', 'market', 'equity']
    if any(keyword in query for keyword in stock_keywords):
        logging.info("Detected general stock query without specific ticker")
        return {**state, "query_type": "stock_general"}

    logging.info("Query not related to finance")
    return {**state, "query_type": "other"}

def fetch_stock_data(state: BotState) -> BotState:
    """Fetch stock data using Yahoo Finance API (via query2.finance.yahoo.com)."""
    logging.info(f"Fetching stock data for: {state['ticker_symbol']}")

    try:
        ticker = state["ticker_symbol"]

        # Use Yahoo Finance API directly (no API key needed)
        url = f"https://query2.finance.yahoo.com/v8/finance/chart/{ticker}"
        params = {
            "interval": "1d",
            "range": "5d"
        }

        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }

        response = requests.get(url, params=params, headers=headers, timeout=10, verify=False)
        response.raise_for_status()
        data = response.json()

        # Check if we got valid data
        if 'chart' not in data or 'result' not in data['chart']:
            return {**state, "error_message": f"No data found for ticker {ticker}. Please check the symbol."}

        result = data['chart']['result'][0]
        meta = result.get('meta', {})

        current_price = meta.get('regularMarketPrice', 0)
        previous_close = meta.get('previousClose', current_price)
        change = current_price - previous_close
        change_percent = (change / previous_close * 100) if previous_close != 0 else 0

        # Get additional quote data
        quote_url = f"https://query2.finance.yahoo.com/v7/finance/quote"
        quote_params = {"symbols": ticker}

        try:
            quote_response = requests.get(quote_url, params=quote_params, headers=headers, timeout=10, verify=False)
            quote_response.raise_for_status()
            quote_data = quote_response.json()

            if 'quoteResponse' in quote_data and 'result' in quote_data['quoteResponse']:
                quote_info = quote_data['quoteResponse']['result'][0]
                company_name = quote_info.get('longName') or quote_info.get('shortName', ticker)
                market_cap = quote_info.get('marketCap')
                high = quote_info.get('regularMarketDayHigh', current_price)
                low = quote_info.get('regularMarketDayLow', current_price)
            else:
                company_name = ticker
                market_cap = None
                high = current_price
                low = current_price
        except:
            company_name = ticker
            market_cap = None
            high = current_price
            low = current_price

        stock_data = {
            "symbol": ticker,
            "name": company_name,
            "current_price": round(current_price, 2),
            "previous_close": round(previous_close, 2),
            "change": round(change, 2),
            "change_percent": round(change_percent, 2),
            "high": round(high, 2),
            "low": round(low, 2),
            "currency": meta.get('currency', 'USD'),
            "market_cap": market_cap,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

        logging.info(f"Successfully fetched stock data for {ticker}")
        return {**state, "stock_data": stock_data}

    except requests.exceptions.RequestException as e:
        error_msg = f"Network error fetching stock data: {str(e)}"
        logging.error(error_msg)
        return {**state, "error_message": error_msg}
    except Exception as e:
        error_msg = f"Error fetching stock data: {str(e)}"
        logging.error(error_msg)
        return {**state, "error_message": error_msg}

def fetch_bitcoin_data(state: BotState) -> BotState:
    """Fetch Bitcoin data from Coinlore API."""
    logging.info("Fetching Bitcoin data")

    try:
        # Coinlore API - Bitcoin ID is 90
        url = "https://api.coinlore.net/api/ticker/"
        params = {"id": "90"}  # 90 is Bitcoin's ID in Coinlore

        response = requests.get(url, params=params, timeout=10, verify=False)
        response.raise_for_status()
        data = response.json()

        if not data or len(data) == 0:
            return {**state, "error_message": "Could not fetch Bitcoin data from Coinlore"}

        bitcoin_info = data[0]

        bitcoin_data = {
            "name": bitcoin_info.get("name", "Bitcoin"),
            "symbol": bitcoin_info.get("symbol", "BTC"),
            "current_price": float(bitcoin_info.get("price_usd", 0)),
            "change_24h": float(bitcoin_info.get("percent_change_24h", 0)),
            "change_1h": float(bitcoin_info.get("percent_change_1h", 0)),
            "change_7d": float(bitcoin_info.get("percent_change_7d", 0)),
            "volume_24h": float(bitcoin_info.get("volume24", 0)) if bitcoin_info.get("volume24") else None,
            "market_cap": float(bitcoin_info.get("market_cap_usd", 0)) if bitcoin_info.get("market_cap_usd") else None,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

        logging.info("Successfully fetched Bitcoin data from Coinlore")
        return {**state, "bitcoin_data": bitcoin_data}

    except requests.exceptions.RequestException as e:
        error_msg = f"Network error fetching Bitcoin data: {str(e)}"
        logging.error(error_msg)
        return {**state, "error_message": error_msg}
    except Exception as e:
        error_msg = f"Error fetching Bitcoin data: {str(e)}"
        logging.error(error_msg)
        return {**state, "error_message": error_msg}

def generate_response(state: BotState) -> BotState:
    """Generate a natural language response based on the data."""
    logging.info("Generating response")

    if state.get("error_message"):
        response = f"Sorry, I encountered an error: {state['error_message']}"
        return {**state, "response": response}

    if state["query_type"] == "stock" and state.get("stock_data"):
        data = state["stock_data"]
        change_direction = "up" if data["change"] >= 0 else "down"
        change_symbol = "+" if data["change"] >= 0 else ""

        response = (
            f"📈 {data['name']} ({data['symbol']})\n"
            f"Current Price: ${data['current_price']} USD\n"
            f"Change: {change_symbol}${data['change']} ({change_symbol}{data['change_percent']:.2f}%)\n"
            f"Previous Close: ${data['previous_close']}\n"
            f"Day Range: ${data['low']} - ${data['high']}\n"
            f"Status: Stock is {change_direction} today"
        )

        if data.get("market_cap"):
            market_cap_b = data["market_cap"] / 1e9
            response += f"\nMarket Cap: ${market_cap_b:.2f}B"

    elif state["query_type"] == "bitcoin" and state.get("bitcoin_data"):
        data = state["bitcoin_data"]
        change_direction = "up" if data["change_24h"] >= 0 else "down"
        change_symbol = "+" if data["change_24h"] >= 0 else ""

        response = (
            f"₿ {data['name']} ({data['symbol']})\n"
            f"Current Price: ${data['current_price']:,.2f} USD\n"
            f"24h Change: {change_symbol}{data['change_24h']:.2f}%\n"
            f"Status: Bitcoin is {change_direction} today"
        )

        if data.get("market_cap"):
            market_cap_b = data["market_cap"] / 1e9
            response += f"\nMarket Cap: ${market_cap_b:.2f}B"

        if data.get("volume_24h"):
            volume_b = data["volume_24h"] / 1e9
            response += f"\n24h Volume: ${volume_b:.2f}B"

    elif state["query_type"] == "stock_general":
        response = (
            "I can help you get stock prices! Please provide a ticker symbol.\n"
            "Examples: 'AAPL price', 'Tesla stock', 'What's MSFT worth?'"
        )

    else:
        response = (
            "🤖 Financial Data Bot\n"
            "I can help you with:\n"
            "• Stock prices (e.g., 'AAPL price', 'Tesla stock')\n"
            "• Bitcoin price (e.g., 'Bitcoin price', 'BTC value')\n"
            "Please ask me about stock tickers or Bitcoin!"
        )

    return {**state, "response": response}

def route_query(state: BotState) -> str:
    """Route to appropriate data fetching node based on query type."""
    query_type = state.get("query_type")

    if query_type == "stock" and state.get("ticker_symbol"):
        return "fetch_stock"
    elif query_type == "bitcoin":
        return "fetch_bitcoin"
    else:
        return "generate_response"

def create_financial_bot() -> CompiledStateGraph:
    """Create the LangGraph-based financial bot."""
    builder = StateGraph(BotState)

    # Add nodes
    builder.add_node("initialize", initialize_state)
    builder.add_node("analyze_query", analyze_query)
    builder.add_node("fetch_stock", fetch_stock_data)
    builder.add_node("fetch_bitcoin", fetch_bitcoin_data)
    builder.add_node("generate_response", generate_response)

    # Add edges
    builder.add_edge(START, "initialize")
    builder.add_edge("initialize", "analyze_query")

    # Conditional routing
    builder.add_conditional_edges(
        "analyze_query",
        route_query,
        {
            "fetch_stock": "fetch_stock",
            "fetch_bitcoin": "fetch_bitcoin",
            "generate_response": "generate_response"
        }
    )

    builder.add_edge("fetch_stock", "generate_response")
    builder.add_edge("fetch_bitcoin", "generate_response")
    builder.add_edge("generate_response", END)

    return builder.compile()

def run_bot(user_query: str) -> str:
    """Run the financial bot with a user query."""
    setup_logging()

    try:
        bot = create_financial_bot()
        logging.info("Financial bot initialized successfully")

        inputs = {"user_query": user_query}
        result = bot.invoke(inputs)
        return result.get("response", "Sorry, I couldn't process your request.")

    except Exception as e:
        logging.error(f"Bot execution error: {e}")
        return f"Sorry, I encountered an error: {str(e)}"

def main():
    """Interactive main function for testing the bot."""
    print("🤖 Financial Data Bot (Alternative APIs)")
    print("=" * 50)
    print("Using Yahoo Finance for stocks & Coinlore for Bitcoin")
    print("No API keys required!")
    print("=" * 50)
    print("\nAsk me about stock prices or Bitcoin!")
    print("Examples: 'AAPL price', 'Bitcoin value', 'Tesla stock'")
    print("Type 'quit' to exit\n")

    while True:
        try:
            user_input = input("You: ").strip()
            if user_input.lower() in ['quit', 'exit', 'q']:
                print("Goodbye! 👋")
                break

            if not user_input:
                continue

            response = run_bot(user_input)
            print(f"\n{response}\n")
            print("-" * 50 + "\n")

        except KeyboardInterrupt:
            print("\n\nGoodbye! 👋")
            break
        except Exception as e:
            print(f"Error: {e}\n")

if __name__ == "__main__":
    main()
