"""Financial Data Bot using LangGraph and yfinance.

This bot provides real-time stock and Bitcoin price information through a conversational interface.
It uses LangGraph for agent orchestration and yfinance for stock data.
"""

import logging
import re
from typing import Any, Dict, List, Optional, TypedDict, Union
from datetime import datetime
import requests
import urllib3
import yfinance as yf
import ssl
from langgraph.graph import END, START, StateGraph
from langgraph.graph.state import CompiledStateGraph
from pydantic_settings import BaseSettings

# Disable SSL verification for yfinance (needed for corporate firewalls)
import certifi
ssl._create_default_https_context = ssl._create_unverified_context

class Settings(BaseSettings):
    """Configuration settings for the financial bot."""

    class Config:
        env_file = '.env'
        env_file_encoding = 'utf-8'
        extra = 'ignore'

def setup_logging(level: int = logging.INFO) -> None:
    """Configure the root logger with consistent formatting."""
    logger = logging.getLogger()
    logger.setLevel(level)

    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    handler = logging.StreamHandler()
    handler.setLevel(level)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

class BotState(TypedDict):
    """State schema for the financial bot."""
    user_query: str
    query_type: Optional[str]  # 'stock', 'bitcoin', 'other'
    ticker_symbol: Optional[str]
    stock_data: Optional[Dict[str, Any]]
    bitcoin_data: Optional[Dict[str, Any]]
    response: Optional[str]
    error_message: Optional[str]

def initialize_state(state: Dict[str, Any]) -> BotState:
    """Initialize the bot's state from user input."""
    logging.info("Initializing bot state")

    user_query = state.get("user_query", "")
    logging.info(f"Processing query: '{user_query}'")

    return {
        "user_query": user_query,
        "query_type": None,
        "ticker_symbol": None,
        "stock_data": None,
        "bitcoin_data": None,
        "response": None,
        "error_message": None
    }

# Company name to ticker lookup dictionary
COMPANY_LOOKUP = {
    # Major Tech Companies
    'apple': 'AAPL',
    'microsoft': 'MSFT',
    'google': 'GOOGL',
    'alphabet': 'GOOGL',
    'amazon': 'AMZN',
    'tesla': 'TSLA',
    'meta': 'META',
    'facebook': 'META',
    'netflix': 'NFLX',
    'nvidia': 'NVDA',
    'amd': 'AMD',
    'intel': 'INTC',

    # Major Banks
    'jpmorgan': 'JPM',
    'bank of america': 'BAC',
    'wells fargo': 'WFC',
    'goldman sachs': 'GS',
    'morgan stanley': 'MS',

    # Other Major Companies
    'berkshire hathaway': 'BRK-B',
    'johnson & johnson': 'JNJ',
    'procter & gamble': 'PG',
    'coca cola': 'KO',
    'pepsi': 'PEP',
    'walmart': 'WMT',
    'disney': 'DIS',
    'nike': 'NKE',
    'mcdonald': 'MCD',
    'mcdonalds': 'MCD',
    'visa': 'V',
    'mastercard': 'MA',
    'salesforce': 'CRM',
    'oracle': 'ORCL',
    'cisco': 'CSCO',
    'ibm': 'IBM',
    'ge': 'GE',
    'general electric': 'GE',
    'ford': 'F',
    'general motors': 'GM',
    'gm': 'GM',
    'boeing': 'BA',
    'caterpillar': 'CAT',
    'home depot': 'HD',
    'lowes': 'LOW',
    'target': 'TGT',
    'costco': 'COST',
    'starbucks': 'SBUX',
    'ups': 'UPS',
    'fedex': 'FDX',
    'exxon': 'XOM',
    'chevron': 'CVX',
    'pfizer': 'PFE',
    'moderna': 'MRNA',
    'abbvie': 'ABBV',
    'zoom': 'ZM',
    'spotify': 'SPOT',
    'uber': 'UBER',
    'lyft': 'LYFT',
    'airbnb': 'ABNB',
    'snapchat': 'SNAP',
    'twitter': 'TWTR',
    'linkedin': 'LNKD',
    'paypal': 'PYPL',
    'square': 'SQ',
    'robinhood': 'HOOD'
}

def find_ticker_from_company_name(query: str) -> str:
    """Find ticker symbol from company name in the query."""
    query_lower = query.lower()

    # Sort by length (longest first) to match "johnson & johnson" before "johnson"
    for company_name in sorted(COMPANY_LOOKUP.keys(), key=len, reverse=True):
        if company_name in query_lower:
            ticker = COMPANY_LOOKUP[company_name]
            logging.info(f"Found company '{company_name}' -> ticker: {ticker}")
            return ticker

    return None

def analyze_query(state: BotState) -> BotState:
    """Analyze user query to determine intent and extract relevant information."""
    logging.info("Analyzing user query")

    query = state["user_query"].lower().strip()

    # Check for Bitcoin/crypto keywords
    bitcoin_keywords = ['bitcoin', 'btc', 'crypto', 'cryptocurrency']
    if any(keyword in query for keyword in bitcoin_keywords):
        logging.info("Detected Bitcoin query")
        return {**state, "query_type": "bitcoin"}

    # First, try to find company names
    company_ticker = find_ticker_from_company_name(state["user_query"])
    if company_ticker:
        logging.info(f"Detected stock query for company name -> ticker: {company_ticker}")
        return {**state, "query_type": "stock", "ticker_symbol": company_ticker}

    # Check for stock tickers (pattern: 2-5 uppercase letters, avoid common words)
    stock_pattern = r'\b[A-Z]{2,5}\b'
    matches = re.findall(stock_pattern, state["user_query"])

    # Filter out common English words that aren't tickers
    common_words = {'I', 'IS', 'IT', 'IN', 'ON', 'TO', 'OF', 'THE', 'AND', 'OR', 'BUT', 'GET', 'CAN', 'HOW', 'YOU', 'YOUR'}
    valid_tickers = [match for match in matches if match not in common_words]

    if valid_tickers:
        ticker = valid_tickers[0]
        logging.info(f"Detected stock query for ticker: {ticker}")
        return {**state, "query_type": "stock", "ticker_symbol": ticker}

    # Check for common stock-related words
    stock_keywords = ['stock', 'share', 'price', 'ticker', 'market', 'equity']
    if any(keyword in query for keyword in stock_keywords):
        logging.info("Detected general stock query without specific ticker")
        return {**state, "query_type": "stock_general"}

    # If none of the above, classify as other
    logging.info("Query not related to finance")
    return {**state, "query_type": "other"}

def fetch_stock_data(state: BotState) -> BotState:
    """Fetch stock data using yfinance."""
    logging.info(f"Fetching stock data for: {state['ticker_symbol']}")

    try:
        ticker = yf.Ticker(state["ticker_symbol"])
        info = ticker.info
        hist = ticker.history(period="1d")

        if hist.empty:
            return {**state, "error_message": f"No data found for ticker {state['ticker_symbol']}"}

        current_price = hist['Close'].iloc[-1]
        previous_close = info.get('previousClose', current_price)
        change = current_price - previous_close
        change_percent = (change / previous_close) * 100 if previous_close != 0 else 0

        stock_data = {
            "symbol": state["ticker_symbol"],
            "name": info.get('longName', state["ticker_symbol"]),
            "current_price": round(current_price, 2),
            "previous_close": round(previous_close, 2),
            "change": round(change, 2),
            "change_percent": round(change_percent, 2),
            "currency": info.get('currency', 'USD'),
            "market_cap": info.get('marketCap'),
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

        logging.info(f"Successfully fetched stock data for {state['ticker_symbol']}")
        return {**state, "stock_data": stock_data}

    except Exception as e:
        error_msg = f"Error fetching stock data: {str(e)}"
        logging.error(error_msg)
        return {**state, "error_message": error_msg}

def fetch_bitcoin_data(state: BotState) -> BotState:
    """Fetch Bitcoin data from CoinGecko API."""
    logging.info("Fetching Bitcoin data")

    try:
        url = "https://api.coingecko.com/api/v3/simple/price"
        params = {
            "ids": "bitcoin",
            "vs_currencies": "usd",
            "include_24hr_change": "true",
            "include_market_cap": "true"
        }

        # Try with SSL verification first
        try:
            response = requests.get(url, params=params, timeout=10, verify=True)
            response.raise_for_status()
            data = response.json()
        except requests.exceptions.SSLError as ssl_error:
            # If SSL verification fails, try without verification (for corporate firewalls)
            logging.warning(f"SSL verification failed: {ssl_error}. Retrying without SSL verification...")
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            response = requests.get(url, params=params, timeout=10, verify=False)
            response.raise_for_status()
            data = response.json()

        bitcoin_info = data["bitcoin"]

        bitcoin_data = {
            "name": "Bitcoin",
            "symbol": "BTC",
            "current_price": bitcoin_info["usd"],
            "change_24h": round(bitcoin_info["usd_24h_change"], 2),
            "market_cap": bitcoin_info["usd_market_cap"],
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

        logging.info("Successfully fetched Bitcoin data")
        return {**state, "bitcoin_data": bitcoin_data}

    except Exception as e:
        error_msg = f"Error fetching Bitcoin data: {str(e)}"
        logging.error(error_msg)
        return {**state, "error_message": error_msg}

def generate_response(state: BotState) -> BotState:
    """Generate a natural language response based on the data."""
    logging.info("Generating response")

    if state.get("error_message"):
        response = f"Sorry, I encountered an error: {state['error_message']}"
        return {**state, "response": response}

    if state["query_type"] == "stock" and state.get("stock_data"):
        data = state["stock_data"]
        change_direction = "up" if data["change"] >= 0 else "down"
        change_symbol = "+" if data["change"] >= 0 else ""

        response = (
            f"{data['name']} ({data['symbol']}) is currently trading at "
            f"${data['current_price']} {data['currency']}. "
            f"That's {change_symbol}${data['change']} ({change_symbol}{data['change_percent']:.2f}%) "
            f"from the previous close of ${data['previous_close']}. "
            f"The stock is {change_direction} today."
        )

        if data.get("market_cap"):
            market_cap_b = data["market_cap"] / 1e9
            response += f" Market cap: ${market_cap_b:.2f}B."

    elif state["query_type"] == "bitcoin" and state.get("bitcoin_data"):
        data = state["bitcoin_data"]
        change_direction = "up" if data["change_24h"] >= 0 else "down"
        change_symbol = "+" if data["change_24h"] >= 0 else ""

        response = (
            f"{data['name']} ({data['symbol']}) is currently trading at "
            f"${data['current_price']:,.2f} USD. "
            f"That's {change_symbol}{data['change_24h']:.2f}% in the last 24 hours. "
            f"Bitcoin is {change_direction} today."
        )

        if data.get("market_cap"):
            market_cap_b = data["market_cap"] / 1e9
            response += f" Market cap: ${market_cap_b:.2f}B."

    elif state["query_type"] == "stock_general":
        response = (
            "I can help you get stock prices! Please provide a ticker symbol. "
            "For example: 'What's AAPL price?' or 'TSLA stock price'"
        )

    else:
        response = (
            "I'm a finance information bot. I can help you with:\n"
            "• Stock prices (e.g., 'AAPL price', 'Tesla stock')\n"
            "• Bitcoin price (e.g., 'Bitcoin price', 'BTC value')\n"
            "Please ask me about stock tickers or Bitcoin!"
        )

    return {**state, "response": response}

def route_query(state: BotState) -> str:
    """Route to appropriate data fetching node based on query type."""
    query_type = state.get("query_type")

    if query_type == "stock" and state.get("ticker_symbol"):
        return "fetch_stock"
    elif query_type == "bitcoin":
        return "fetch_bitcoin"
    else:
        return "generate_response"

def create_financial_bot() -> CompiledStateGraph:
    """Create the LangGraph-based financial bot."""
    builder = StateGraph(BotState)

    # Add nodes
    builder.add_node("initialize", initialize_state)
    builder.add_node("analyze_query", analyze_query)
    builder.add_node("fetch_stock", fetch_stock_data)
    builder.add_node("fetch_bitcoin", fetch_bitcoin_data)
    builder.add_node("generate_response", generate_response)

    # Add edges
    builder.add_edge(START, "initialize")
    builder.add_edge("initialize", "analyze_query")

    # Conditional routing after query analysis
    builder.add_conditional_edges(
        "analyze_query",
        route_query,
        {
            "fetch_stock": "fetch_stock",
            "fetch_bitcoin": "fetch_bitcoin",
            "generate_response": "generate_response"
        }
    )

    # Both data fetching nodes lead to response generation
    builder.add_edge("fetch_stock", "generate_response")
    builder.add_edge("fetch_bitcoin", "generate_response")
    builder.add_edge("generate_response", END)

    return builder.compile()

def run_bot(user_query: str) -> str:
    """Run the financial bot with a user query."""
    setup_logging()

    try:
        bot = create_financial_bot()
        logging.info("Financial bot initialized successfully")

        inputs = {"user_query": user_query}

        result = bot.invoke(inputs)
        return result.get("response", "Sorry, I couldn't process your request.")

    except Exception as e:
        logging.error(f"Bot execution error: {e}")
        return f"Sorry, I encountered an error: {str(e)}"

def main():
    """Interactive main function for testing the bot."""
    print("🤖 Financial Data Bot")
    print("Ask me about stock prices or Bitcoin!")
    print("Examples: 'AAPL price', 'Bitcoin value', 'TSLA stock'")
    print("Type 'quit' to exit\n")

    while True:
        try:
            user_input = input("You: ").strip()
            if user_input.lower() in ['quit', 'exit', 'q']:
                print("Goodbye!")
                break

            if not user_input:
                continue

            response = run_bot(user_input)
            print(f"Bot: {response}\n")

        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Error: {e}\n")

if __name__ == "__main__":
    main()
